# 알고리즘

### 시간 복잡도 계산

- 빅오 O( ) -> 최악의 경우
- 오메가 Ω( ) -> 최선의 경우
- 쎄타 Θ( )
- 빅오를 쓰는 이유는 최악의 경우기에, 한계를 알 수 있다.
- 쎄타의 경우는 빅오와 오메가가 같을 경우에 사용.(사실상 빅오라고 생각해도 된다.)



### 검색

- 순차 검색 : 가장 직관적이면서 비효율적일 가능성이 큰 방법(하나하나 확인). 최악의 경우는 마지막에 있거나 없는 경우임.
- 이진 탐색 : 선제 조건으로 자료가 정렬된 상태여야 함. 정렬되어 있기에 추측해가며 검색. 최악의 경우를 파악하기 쉽다! 계속 중간을 나눠서 한쪽으로만 파악해가며 범위를 좁혀나감. log_2_n만큼의 연산량.
- 완전 탐색 : 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 방법.



### 정렬

같은 자료형일때 비교할 수 있다.

- 거품 정렬 : 인접한 두 개의 원소를 비교하며, 자리를 계속 교환
- 선택 정렬 : 원하는 값을 찾아 위치를 앞으로 이동시킴
- 카운트 정렬 : 중복되는 수를 찾아 그만큼의 누적수를 저장함. 원래 데이터를 참조해가면서 저장된 누적수 만큼 인덱스로 변수에(누적 카운트 수 == 새로운 변수의 인덱스) 저장. 이때 누적 카운트 수는 원래 데이터에서 만날때마다 하나씩 줄인다.